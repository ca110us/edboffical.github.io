<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>SQL Server Weak Password Detection - callous' blog</title><meta name=keywords content="tech"><meta name=description content="Recently, during the development of the Windows security agent, there is a feature to perform weak password detection on SQL Server. To obtain a feasible solution, we need to first understand how SQL Server stores and verifies passwords.
Hash algorithm and verification function The calculation and verification of password hash are actually reverse processes and former can deduce the latter. This article only focuses on versions after SQL Server 2012. Since that, SQL Server has been using the same algorithm, which is more universal."><meta name=author content="callous"><link rel=canonical href=https://callous.cn/blog/tech/weak/><link href=https://callous.cn/assets/css/stylesheet.min.595f5ecef354f9eb94e43d831cd360dcf8b7727542e731c55a7875c9e94a9577.css integrity="sha256-WV9ezvNU+euU5D2DHNNg3Pi3cnVC5zHFWnh1yelKlXc=" rel="preload stylesheet" as=style><link rel=manifest href=https://callous.cn/site.webmanifest><link rel=icon href=https://callous.cn/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://callous.cn/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://callous.cn/favicon-32x32.png><link rel=apple-touch-icon href=https://callous.cn/apple-touch-icon.png><link rel=mask-icon href=https://callous.cn/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.78.1"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','G-2C1K8EY548','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="SQL Server Weak Password Detection"><meta property="og:description" content="Recently, during the development of the Windows security agent, there is a feature to perform weak password detection on SQL Server. To obtain a feasible solution, we need to first understand how SQL Server stores and verifies passwords.
Hash algorithm and verification function The calculation and verification of password hash are actually reverse processes and former can deduce the latter. This article only focuses on versions after SQL Server 2012. Since that, SQL Server has been using the same algorithm, which is more universal."><meta property="og:type" content="article"><meta property="og:url" content="https://callous.cn/blog/tech/weak/"><meta property="article:published_time" content="2023-04-19T23:45:00+08:00"><meta property="article:modified_time" content="2023-04-19T23:45:00+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SQL Server Weak Password Detection"><meta name=twitter:description content="Recently, during the development of the Windows security agent, there is a feature to perform weak password detection on SQL Server. To obtain a feasible solution, we need to first understand how SQL Server stores and verifies passwords.
Hash algorithm and verification function The calculation and verification of password hash are actually reverse processes and former can deduce the latter. This article only focuses on versions after SQL Server 2012. Since that, SQL Server has been using the same algorithm, which is more universal."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SQL Server Weak Password Detection","name":"SQL Server Weak Password Detection","description":"Recently, during the development of the Windows security agent, there is a feature to perform weak password detection on SQL Server. To obtain a feasible solution, we need to first …","keywords":["tech"],"articleBody":"Recently, during the development of the Windows security agent, there is a feature to perform weak password detection on SQL Server. To obtain a feasible solution, we need to first understand how SQL Server stores and verifies passwords.\nHash algorithm and verification function The calculation and verification of password hash are actually reverse processes and former can deduce the latter. This article only focuses on versions after SQL Server 2012. Since that, SQL Server has been using the same algorithm, which is more universal. Hash Algorithms – How does SQL Server store Passwords? This article provides a detailed introduction to this algorithm and presents its implementation using SQL statements.\nDECLARE @pswd NVARCHAR(MAX) = 'APassword'; DECLARE @salt VARBINARY(4) = CRYPT_GEN_RANDOM(4); DECLARE @hash VARBINARY(MAX); SET @hash = 0x0200 + @salt + HASHBYTES('SHA2_512', CAST(@pswd AS VARBINARY(MAX)) + @salt); SELECT @hash AS HashValue, PWDCOMPARE(@pswd,@hash) AS IsPasswordHash; You can see that the password hash value is a hexadecimal string presented in the following format:\n{0x200 (fixed prefix)} + {4 bytes random salt} + {SHA_512(password+salt)} Since the salt is random 4 bytes each time, even for the same plain text password, the hash will always differ.\nThen I translated this algorithm into the go code:\nfunc hashPassword(password string, salt []byte) []byte { saltedPassword := append([]byte(password), salt...) sha512hash := sha512.Sum512(saltedPassword) hashedPassword := append(salt, sha512hash[:]...) return hashedPassword } However, there is a problem, even if the same salt is used in the go code and SQL statements, the resulting hash values are different.\nAnd finally I noticed that the data type for ‘pswd’ was NVARCHAR instead of VARCHAR. Both data types are utilized for storing strings with variable lengths, but NVARCHAR encodes each character using 2 bytes (16 bits), while VARCHAR uses only 1 byte (8 bits) per character.\nSo the issue of the go code is that when I use []byte(password) to convert the string into a byte slice, Go actually use UTF8 encoding, which is a variable-length encoding that utilizes 1-4 bytes for encoding each character. The data was wrong here because we need to encode strings with a fixed 2 bytes for each character, such as UTF16. Here is the code after ChatGPT fixed it for me.:\nfunc utf16Bytes(input string) []byte { utf16bytes := []rune(input) bytes := make([]byte, len(utf16bytes)*2) for i, v := range utf16bytes { bytes[i*2] = byte(v) bytes[i*2+1] = byte(v  8) } return bytes } func hashPassword(password string, salt []byte) []byte { saltedPassword := append(utf16Bytes(password), salt...) sha512hash := sha512.Sum512(saltedPassword) hashedPassword := append(salt, sha512hash[:]...) return hashedPassword } func verifyPassword(hashedPassword []byte, password string) bool { salt := hashedPassword[:4] originalHash := hashedPassword[4:] saltedPassword := append(utf16Bytes(password), salt...) sha512hash := sha512.Sum512(saltedPassword) return bytes.Equal(originalHash, sha512hash[:]) } I finished the verification function by the way, and as I said above, this is actually a reverse process.\nExtract user password hash Now we have the hash algorithm and verification function, we need to figure out a way to get password hashes from SQL Server for our upcoming auditing work.\nExtracting SQL Server Hashes From master.mdf This article shows us a way to extract password hashes from the master.mdf file and provides the PowerShell script. We can locate the MDF file from this location and extract hashes from it. The ‘test’ user is an account I created it for test, its plaintext password is 123456, and its hash is\n0x0200CC6368C75E9C63B876C62F18457C6A0EB96E3E1D602540057045FBC77054F5D72B9E43900E2FC72D5130FD1DF9FBD0784923B39BF57C600BA8B977F8E5A0B035E93F5F0B We can use this code to verify the plaintext password:\nbytes, _ := hex.DecodeString(\"CC6368C75E9C63B876C62F18457C6A0EB96E3E1D602540057045FBC77054F5D72B9E43900E2FC72D5130FD1DF9FBD0784923B39BF57C600BA8B977F8E5A0B035E93F5F0B\") fmt.Println(verifyPassword(bytes, \"123456\")) The above code will output true.\nThe final step The last step is to match the hash against each plaintext password contained within a weak password dictionary file.\n","wordCount":"593","inLanguage":"en","datePublished":"2023-04-19T23:45:00+08:00","dateModified":"2023-04-19T23:45:00+08:00","author":{"@type":"Person","name":"callous"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://callous.cn/blog/tech/weak/"},"publisher":{"@type":"Organization","name":"callous' blog","logo":{"@type":"ImageObject","url":"https://callous.cn/favicon.ico"}}}</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','G-2C1K8EY548','auto');ga('send','pageview');}</script></head><body class=single id=top><script>if(localStorage.getItem("pref-theme")==="dark"){document.body.classList.add('dark');}else if(localStorage.getItem("pref-theme")==="light"){document.body.classList.remove('dark')}else if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><noscript><style type=text/css>.theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://callous.cn accesskey=h>callous' blog</a>
<span class=logo-switches><span class=theme-toggle><a id=theme-toggle accesskey=t><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></a></span></span></div><ul class=menu id=menu onscroll=menu_on_scroll()><li><a href=https://callous.cn/archives/><span>Archives</span></a></li><li><a href=https://callous.cn/tags/><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SQL Server Weak Password Detection</h1><div class=post-meta>April 19, 2023&nbsp;·&nbsp;3 min&nbsp;·&nbsp;callous</div></header><div class=post-content><p>Recently, during the development of the Windows security agent, there is a feature to perform weak password detection on SQL Server. To obtain a feasible solution, we need to first understand how SQL Server stores and verifies passwords.</p><h2 id=hash-algorithm-and-verification-function>Hash algorithm and verification function</h2><p>The calculation and verification of password hash are actually reverse processes and former can deduce the latter. This article only focuses on versions after SQL Server 2012. Since that, SQL Server has been using the same algorithm, which is more universal. <a href=https://sqlity.net/en/2460/sql-password-hash/>Hash Algorithms – How does SQL Server store Passwords?</a> This article provides a detailed introduction to this algorithm and presents its implementation using SQL statements.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>DECLARE</span> <span style=color:#f92672>@</span>pswd NVARCHAR(<span style=color:#66d9ef>MAX</span>) <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;APassword&#39;</span>;
<span style=color:#66d9ef>DECLARE</span> <span style=color:#f92672>@</span>salt VARBINARY(<span style=color:#ae81ff>4</span>) <span style=color:#f92672>=</span> CRYPT_GEN_RANDOM(<span style=color:#ae81ff>4</span>);
<span style=color:#66d9ef>DECLARE</span> <span style=color:#f92672>@</span>hash VARBINARY(<span style=color:#66d9ef>MAX</span>);
<span style=color:#66d9ef>SET</span> <span style=color:#f92672>@</span>hash <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>x0200 <span style=color:#f92672>+</span> <span style=color:#f92672>@</span>salt <span style=color:#f92672>+</span> HASHBYTES(<span style=color:#e6db74>&#39;SHA2_512&#39;</span>, <span style=color:#66d9ef>CAST</span>(<span style=color:#f92672>@</span>pswd <span style=color:#66d9ef>AS</span> VARBINARY(<span style=color:#66d9ef>MAX</span>)) <span style=color:#f92672>+</span> <span style=color:#f92672>@</span>salt);
<span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>@</span>hash <span style=color:#66d9ef>AS</span> HashValue, PWDCOMPARE(<span style=color:#f92672>@</span>pswd,<span style=color:#f92672>@</span>hash) <span style=color:#66d9ef>AS</span> IsPasswordHash;
</code></pre></div><p>You can see that the password hash value is a hexadecimal string presented in the following format:</p><pre><code>{0x200 (fixed prefix)} + {4 bytes random salt} + {SHA_512(password+salt)}
</code></pre><p>Since the salt is random 4 bytes each time, even for the same plain text password, the hash will always differ.</p><p>Then I translated this algorithm into the go code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hashPassword</span>(<span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>salt</span> []<span style=color:#66d9ef>byte</span>) []<span style=color:#66d9ef>byte</span> {
	<span style=color:#a6e22e>saltedPassword</span> <span style=color:#f92672>:=</span> append([]byte(<span style=color:#a6e22e>password</span>), <span style=color:#a6e22e>salt</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>sha512hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sha512</span>.<span style=color:#a6e22e>Sum512</span>(<span style=color:#a6e22e>saltedPassword</span>)
	<span style=color:#a6e22e>hashedPassword</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>salt</span>, <span style=color:#a6e22e>sha512hash</span>[:]<span style=color:#f92672>...</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hashedPassword</span>
}
</code></pre></div><p>However, there is a problem, even if the same salt is used in the go code and SQL statements, the resulting hash values are different.</p><p>And finally I noticed that the data type for &lsquo;pswd&rsquo; was <code>NVARCHAR</code> instead of <code>VARCHAR</code>. Both data types are utilized for storing strings with variable lengths, but <code>NVARCHAR</code> encodes each character using 2 bytes (16 bits), while <code>VARCHAR</code> uses only 1 byte (8 bits) per character.</p><p>So the issue of the go code is that when I use []byte(password) to convert the string into a byte slice, Go actually use <code>UTF8</code> encoding, which is a variable-length encoding that utilizes 1-4 bytes for encoding each character. The data was wrong here because we need to encode strings with a fixed 2 bytes for each character, such as <code>UTF16</code>. Here is the code after ChatGPT fixed it for me.:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>utf16Bytes</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>) []<span style=color:#66d9ef>byte</span> {
	<span style=color:#a6e22e>utf16bytes</span> <span style=color:#f92672>:=</span> []rune(<span style=color:#a6e22e>input</span>)
	<span style=color:#a6e22e>bytes</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, len(<span style=color:#a6e22e>utf16bytes</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>utf16bytes</span> {
		<span style=color:#a6e22e>bytes</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span>] = byte(<span style=color:#a6e22e>v</span>)
		<span style=color:#a6e22e>bytes</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#ae81ff>2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] = byte(<span style=color:#a6e22e>v</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>8</span>)
	}

	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bytes</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hashPassword</span>(<span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>salt</span> []<span style=color:#66d9ef>byte</span>) []<span style=color:#66d9ef>byte</span> {
	<span style=color:#a6e22e>saltedPassword</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>utf16Bytes</span>(<span style=color:#a6e22e>password</span>), <span style=color:#a6e22e>salt</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>sha512hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sha512</span>.<span style=color:#a6e22e>Sum512</span>(<span style=color:#a6e22e>saltedPassword</span>)
	<span style=color:#a6e22e>hashedPassword</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>salt</span>, <span style=color:#a6e22e>sha512hash</span>[:]<span style=color:#f92672>...</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hashedPassword</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>verifyPassword</span>(<span style=color:#a6e22e>hashedPassword</span> []<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>bool</span> {
	<span style=color:#a6e22e>salt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hashedPassword</span>[:<span style=color:#ae81ff>4</span>]
	<span style=color:#a6e22e>originalHash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hashedPassword</span>[<span style=color:#ae81ff>4</span>:]
	<span style=color:#a6e22e>saltedPassword</span> <span style=color:#f92672>:=</span> append(<span style=color:#a6e22e>utf16Bytes</span>(<span style=color:#a6e22e>password</span>), <span style=color:#a6e22e>salt</span><span style=color:#f92672>...</span>)
	<span style=color:#a6e22e>sha512hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sha512</span>.<span style=color:#a6e22e>Sum512</span>(<span style=color:#a6e22e>saltedPassword</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>originalHash</span>, <span style=color:#a6e22e>sha512hash</span>[:])
}
</code></pre></div><p>I finished the verification function by the way, and as I said above, this is actually a reverse process.</p><h2 id=extract-user-password-hash>Extract user password hash</h2><p>Now we have the hash algorithm and verification function, we need to figure out a way to get password hashes from SQL Server for our upcoming auditing work.</p><p><a href=https://blog.xpnsec.com/extracting-master-mdf-hashes/>Extracting SQL Server Hashes From master.mdf</a> This article shows us a way to extract password hashes from the master.mdf file and provides the PowerShell script. We can locate the MDF file from this location and extract hashes from it.
<img src=../../../tech/weak/1.png alt=mdf>
<img src=../../../tech/weak/2.png alt=dump>
The &lsquo;test&rsquo; user is an account I created it for test, its plaintext password is <code>123456</code>, and its hash is</p><pre><code>0x0200CC6368C75E9C63B876C62F18457C6A0EB96E3E1D602540057045FBC77054F5D72B9E43900E2FC72D5130FD1DF9FBD0784923B39BF57C600BA8B977F8E5A0B035E93F5F0B
</code></pre><p>We can use this code to verify the plaintext password:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>bytes</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hex</span>.<span style=color:#a6e22e>DecodeString</span>(<span style=color:#e6db74>&#34;CC6368C75E9C63B876C62F18457C6A0EB96E3E1D602540057045FBC77054F5D72B9E43900E2FC72D5130FD1DF9FBD0784923B39BF57C600BA8B977F8E5A0B035E93F5F0B&#34;</span>)

<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>verifyPassword</span>(<span style=color:#a6e22e>bytes</span>, <span style=color:#e6db74>&#34;123456&#34;</span>))
</code></pre></div><p>The above code will output true.</p><h2 id=the-final-step>The final step</h2><p>The last step is to match the hash against each plaintext password contained within a weak password dictionary file.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://callous.cn/tags/tech>tech</a></li></ul></footer><figure class=article-discussion><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"edboffical"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></figure></article></main><footer class=footer><span>&copy; 2023 <a href=https://callous.cn>callous' blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top" accesskey=g><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://callous.cn/assets/js/highlight.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js integrity="sha256-56/CkowJJdZcRzLf6+FHAU2RKZqY6BnktC8lxPpo6Rw="></script><script>hljs.initHighlightingOnLoad();</script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);document.querySelector(`[id='${id}']`).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{if(document.body.className.includes("dark")){document.body.classList.remove('dark');localStorage.setItem("pref-theme",'light');}else{document.body.classList.add('dark');localStorage.setItem("pref-theme",'dark');}})</script></body></html>